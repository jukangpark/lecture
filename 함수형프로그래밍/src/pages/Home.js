const Home = () => {
  // 모든 프로그래밍의 패러다임은 -> 성공적인 프로그래밍을 위해
  // 성공적인 프로그래밍이란? -> 좋은 프로그램
  // 좋은 프로그램이란 -> 사용성, 성능, 확장성, 기획 변경에 대응력 등이 있으며,
  // 이것들을 효율적이고 생산적으로 이루는 일이 성공적인 프로그래밍이다.

  // 함수형 프로그래밍은 성공적인 프로그래밍을 위해 부수 효과를 최대한 멀리하고,
  // 조합성을 강조하는 프로그래밍 패러다임이다.
  // 함수형 프로그래밍이 부수 효과를 최대한 멀리하는 이유 2가지
  // 1. 오류를 줄이기 위해서
  // 2. 조합성 혹은 모듈화 수준을 높이기 위해서

  // # 평가
  // - 코드가 계산(Evaluation) 되어 값을 만드는 것

  // # 일급
  // - 값으로 다룰 수 있다.
  // - 변수에 담을 수 있다.
  // - 함수의 인자로 사용될 수 있다.
  // - 함수의 결과로 사용될 수 있다.

  // # 일급 함수
  // - 함수를 값으로 다룰 수 있다.
  // - 조합성과 추상화의 도구

  const a = 10;
  const add10 = (a) => a + 10;
  const r = add10(a);

  const add5 = (a) => a + 5;
  console.log(add5);
  console.log(add5(5));

  const f1 = () => () => 1;
  console.log(f1());

  const f2 = f1();
  console.log(f2);
  console.log(f2());

  const addMaker = (a) => {
    return function (b) {
      return a + b;
    };
  };

  console.log(addMaker(10)(5)); // 15
  // 이 예제는 매우 간단하지만, 값으로서의 함수, 클로저, 스코프 등의 많은 이야기를 담고 있다.
  // 함수는 값을 리턴할 수 있고, 함수는 값이 될 수 있다.
  // addMaker 는 내부에서 함수를 정의하고 리턴했다.
  // addMaker 가 리턴한 익명 함수는 '클로저'가 되었다.
  // 리턴된 익명 함수 내부에서 a 가 정의된 적은 없지만,
  // a 를 참조하고 있고,
  // a 는 부모 스코프에 있다.
  // a 는 불변하며, 상수로 쓰이게 된다. -> 이 상황에서는 불변하지만, 모든 경우의 클로저가 그런건 아니다.
  // 지금은 그저 위와 같은 코드가 '값으로서의 함수' 와 '클로저'를 이용한 함수형 JS 스타일중 하나

  return (
    <div>
      <h1>Home</h1>
    </div>
  );
};

export default Home;
